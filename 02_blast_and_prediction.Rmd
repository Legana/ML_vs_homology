---
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Using BLAST and AMP prediction models to find AMPs from proteomes

```{r, echo = FALSE}
library(tidyverse)
library(ampir)
library(patchwork)
```

## Proteomes

The proteomes were downloaded from [UniProt](https://www.uniprot.org/proteomes) on 23 June 2021.

**Table 1:** Proteome information from organisms used as subjects 

| Organism Name | Reference proteome ID | Total proteins | Reviewed | Unreviewed | AMPs (rev) | AMPs (unrev) | Gene count |
| --------------- | --------------- | --------------- | --------------- | --------------- |--------------- | --------------- | --------------- |
| *Mus musculus* | [UP000000589](https://www.uniprot.org/proteomes/UP000000589) | 55,366 | 17,077 | 38,289 | 100 | 31 | 22,001
| *Homo sapiens* | [UP000005640](https://www.uniprot.org/proteomes/UP000005640) | 78,120 | 20,371 | 57,749 | 99 | 16 | 20,600
| *Rattus norvegicus* | [UP000002494](https://www.uniprot.org/proteomes/UP000002494) | 29,934 | 8,131 | 21,803 | 52 | 36 | 21,588 |
| *Bos taurus* | [UP000009136](https://www.uniprot.org/proteomes/UP000009136) | 37,513 | 6,014 | 31,499 | 55 | 61 | 23,847
| *Pan troglodytes* | [UP000002277](https://www.uniprot.org/proteomes/UP000002277) | 48,770 | 692 | 48,078 | 38 | 27 | 23,053 |
| *Sus scrofa* | [UP000008227](https://www.uniprot.org/proteomes/UP000008227) | 49,792 | 1,438 | 48,354 | 29 | 46 | 22,165 |
| *Canis lupus familiaris* | [UP000002254](https://www.uniprot.org/proteomes/UP000002254) | 45,351 | 44,518 | 833 | 6 | 45 | 20,654 |
| *Rhinolophus ferrumequinum* | [UP000472240](https://www.uniprot.org/proteomes/UP000472240) | 33,504 | 27 | 33,477 | 0 | 37 | 19,443 |



```{r}
read_proteome_metadata <- function(path, organism) {
  read_tsv(path, col_types = cols()) %>%
  rename("Entry_name" = `Entry name`) %>%
  mutate(Organism = organism) %>% 
  mutate(Label = case_when(str_detect(Keywords, "Antimicrobial") ~ "Pos", TRUE ~ "Neg"))
}

mouse_proteome_metadata <- read_proteome_metadata("data/proteomes/M_musculus-proteome-UP000000589.tab.gz", "Mus_musculus")
cow_proteome_metadata <- read_proteome_metadata("data/proteomes/B_taurus-proteome-UP000009136.tab.gz", "Bos_taurus")
#rat_proteome_metadata <- read_proteome_metadata("data/proteomes/")
```

This mouse `UP000000589_10090.fasta.gz` proteome is from the "one protein sequence per gene" containing 22,001 proteins. This proteome contains all reviewed AMPs (100) and 20 out of 31 unreviewed AMPs. The cow `B_taurus_UP000009136_9913.fasta.gz` proteome containing 23,847 proteins which contained all reviewed AMPs (55) and 54 out of 61 unreviewed AMPs.

NOTE: -- maybe replace "full" proteomes with the "unique" proteome and use both reviewed AND unreviewed AMPs as benchmark result..

```{r, eval = FALSE, echo = FALSE}
mouse_proteome_1prot_w_metadata <- read_faa("data/proteomes/M_musculus_UP000000589_10090.fasta.gz") %>% mutate(Entry_name = str_extract(seq_name, "(?<=\\|)[a-zA-Z0-9_]*(?=\\s)")) %>% left_join(mouse_proteome_metadata)

mouse_proteome_1prot_w_metadata %>% filter(Status == "reviewed") %>% filter(Label == "Pos") %>% nrow()
mouse_proteome_metadata %>% filter(Status == "reviewed") %>% filter(Label == "Pos") %>% nrow()

mouse_proteome_1prot_w_metadata  %>% filter(Status == "unreviewed") %>% filter(Label == "Pos") %>% nrow()
mouse_proteome_metadata %>% filter(Status == "unreviewed") %>% filter(Label == "Pos") %>% nrow()

cow_proteome_1prot_w_metadata <- read_faa("data/proteomes/B_taurus_UP000009136_9913.fasta.gz") %>% mutate(Entry_name = str_extract(seq_name, "(?<=\\|)[a-zA-Z0-9_]*(?=\\s)")) %>% left_join(cow_proteome_metadata)

cow_proteome_1prot_w_metadata  %>% filter(Status == "reviewed") %>% filter(Label == "Pos") %>% nrow()
cow_proteome_metadata  %>% filter(Status == "reviewed") %>% filter(Label == "Pos") %>% nrow()

cow_proteome_1prot_w_metadata  %>% filter(Status == "unreviewed") %>% filter(Label == "Pos") %>% nrow()
cow_proteome_metadata %>% filter(Status == "unreviewed") %>% filter(Label == "Pos") %>% nrow()
```

## BLAST searches to find AMPs

The [BLAST+](https://pubmed.ncbi.nlm.nih.gov/20003500/) version used was blast 2.11.0, build Nov 17 2020 for MacOS.

Each proteome was used to make a local BLAST database using `makeblastdb`. This proteome database was then used to query the AMP dataset with `blastp`, Protein-Protein BLAST 2.11.0+. The [blast01_proteomeagainstAMPs](scripts/blast01_proteomeagainstAMPs.sh)  script was used for this. This BLAST method is henceforth referred to as the "BLAST1" method.

```bash
gunzip -d data/proteomes/M_musculus_UP000000589_10090.fasta.gz 

makeblastdb -in data/proteomes/M_musculus_UP000000589_10090.fasta -dbtype 'prot' 

blastp -db data/proteomes/M_musculus_UP000000589_10090.fasta -query cache/Mus_musculus.fasta -outfmt 6 -max_target_seqs 5 -evalue=10 > data/blastp_results/Mus_musculus2.blastp 

find data/proteomes/ -type f -not -name '*.gz' -delete
```


BLAST was also performed the other way around, using Mus_musculus.fasta as the database and query it against M_musculus proteome (referred to as the BLAST2 method) This was done on the HPC. See [blast02_AMPsagainstproteome.sh](scripts/blast02_AMPsagainstproteome.sh) for the script used.

The standard BLAST tabular output consists of nine columns:
            
1. qaccver - Query accession.version (AMPs list ID)
2. saccver - Subject accession.version (Reference proteome ID)
3. pident - Percentage of identical matches
4. length - Alignment length (sequence overlap)
5. mismatch - Number of mismatches
6. gapopen - Number of gap openings
7. qstart - Start of alignment in query
8. qend - End of alignment in query
9. sstart - Start of alignment in subject
10. send - End of alignment in subject
11. evalue - Expect value (the smaller the evalue, the better the homology match)
12. bitscore - Bit score (the higher the bitscore, the better the sequence similarity)

        

```{r}
parse_blast_results <- function(blast_results_path, metadata) {
  
  blast_colnames <- c("qaccver","saccver","pident","length","mismatch","gapopen","qstart","qend","sstart","send","evalue","bitscore")
  
  read_tsv(blast_results_path, col_names = blast_colnames) %>% 
  group_by(saccver) %>% 
  slice_max(n = 1, order_by = bitscore) %>%
  separate(saccver, into = c(NA, NA, "Entry_name"), sep = "\\|") %>%
  right_join(metadata, by = "Entry_name") %>% 
  mutate(bitscore = replace_na(bitscore, 0))
}

mouse_amps_blast <- parse_blast_results("data/blastp_results/Mus_musculus.blastp", mouse_proteome_metadata)

cow_amps_blast <- parse_blast_results("data/blastp_results/Bos_taurus.blastp", cow_proteome_metadata)


```

*sanity check, remove*
```{r}
mouse_amps_blast %>% filter(Status == "reviewed") %>% filter(Label=="Pos") %>% filter(bitscore >= 0.5) %>% n_distinct()

cow_amps_blast %>%   filter(Status == "reviewed") %>% filter(Label == "Pos") %>% n_distinct()

```

*BLAST2 method:*
```{r}
parse_blast2_results <- function(blast_results_path, metadata) {
  blast_colnames <- c("qaccver","saccver","pident","length","mismatch","gapopen","qstart","qend","sstart","send","evalue","bitscore")
  read_tsv(blast_results_path, col_names = blast_colnames) %>% 
  group_by(qaccver) %>% 
  slice_max(n = 1, order_by = bitscore) %>%
  separate(qaccver, into = c(NA, NA, "Entry_name"), sep = "\\|") %>%
  right_join(metadata, by = "Entry_name") %>% 
  mutate(bitscore = replace_na(bitscore, 0))
}


mouse_proteome_blast <- parse_blast2_results("data/blastp_results/Mus_musculus_proteome.blastp", mouse_proteome_metadata)

cow_proteome_blast <- parse_blast2_results("data/blastp_results/Bos_taurus_proteome.blastp", cow_proteome_metadata)


```

"For average length proteins, a bit score of 50 is almost always significant. A bit score of 40 is only significant (E() < 0.001) in searches of protein databases with fewer than 7000 entries"[Pearson 2013, pp. 4-5](https://doi.org/10.1002/0471250953.bi0301s42)

```{r}
max(mouse_proteome_blast$bitscore)
min(mouse_proteome_blast$bitscore)
```


```{r}
organisms = c("Mus_musculus","Bos_taurus")

source("scripts/calc_cm_metrics_from_bitscore.R")

get_blast_roc <- function(data, method){
  do.call(rbind,lapply(organisms,function(org){ 
    map_df(seq(0, 1000, 1), calc_cm_metrics_from_bitscore, data %>% filter(Organism==org)) %>%
    add_column(Organism = org)
  })) %>%   
  add_column(Method = method)
}

source("scripts/calc_cm_metrics_from_prob.R")

get_proteome_roc <- function(data, method){
  do.call(rbind,lapply(organisms,function(org){ 
    map_df(c(seq(0.01, 0.99, 0.01),seq(0.99, 0.990, 0.001)), calc_cm_metrics_from_prob, data %>% filter(Organism==org)) %>%
    add_column(Organism = org)
  })) %>%   
  add_column(Method = method)
}
```

```{r, eval = FALSE}
mouse_amps_blast1_roc <- get_blast_roc(mouse_amps_blast, method = "BLAST1")

mouse_proteome_blast2_roc <- get_blast_roc(mouse_proteome_blast, method = "BLAST2")


cow_amps_blast1_roc <- get_blast_roc(cow_amps_blast, method = "BLAST1")

cow_proteome_blast2_roc <- get_blast_roc(cow_proteome_blast, method = "BLAST2")


blast_roc <- rbind(mouse_amps_blast1_roc, mouse_proteome_blast2_roc, cow_amps_blast1_roc, cow_proteome_blast2_roc)

saveRDS(blast_roc, "cache/blast_roc.rds")
```

```{r, echo = FALSE}
blast_roc <- readRDS("cache/blast_roc.rds")
```



## Prediction with AMP classification model  

```{r}
mouse_model <- readRDS("models/Mus_musculus_model.rds")
cow_model <- readRDS("models/Bos_taurus_model.rds")
```

```{r, eval=FALSE}
mouse_pred <- predict_amps(mouse_proteome, n_cores = 2, model = mouse_model)
cow_pred <- predict_amps(cow_proteome, n_cores = 3, model = cow_model)
```

```{r, echo = FALSE, eval = FALSE}
saveRDS(mouse_pred, "cache/mouse_pred.rds")
saveRDS(cow_pred, "cache/cow_pred.rds")
```

```{r, echo = FALSE}
mouse_pred <- readRDS("cache/mouse_pred.rds")
cow_pred <- readRDS("cache/cow_pred.rds")
```

Regex: Three steps to extract the `Entry_name` text that is between a Unix pipe and a space: 

1. Lookbehind `(?<=\\|)` matches only if preceding character is a Unix pipe (\\|) 
2. Match only alphanumerics and underscores `[a-zA-Z0-9_]*`
3. Lookahead `(?=\\s)` Matches only if the next character is a space (\\s)

```{r}
join_pred_with_metadata <- function(pred_data, metadata){
  pred_data %>%
  mutate(Entry_name = str_extract(seq_name, "(?<=\\|)[a-zA-Z0-9_]*(?=\\s)")) %>% 
  select(Entry_name, seq_aa, prob_AMP) %>% 
  left_join(metadata, by = "Entry_name") %>%
  filter(Status == "reviewed")
}
```


```{r}
mouse_proteome_pred <- join_pred_with_metadata(mouse_pred, mouse_proteome_metadata)

cow_proteome_pred <- join_pred_with_metadata(cow_pred, cow_proteome_metadata)



proteome_predictions <- rbind(mouse_proteome_pred, cow_proteome_pred) 
```



```{r}
pred_roc <- get_proteome_roc(proteome_predictions, "Classification")
```

*combine BLAST and prediction results*
```{r}
blast_pred_roc <- rbind(blast_roc, pred_roc)
```

  
```{r, echo = FALSE}
ggplot(blast_pred_roc) +
  geom_line(aes(x = Recall, y = Precision, colour = Method)) +
  facet_wrap(~Organism) +
  theme_classic() +
  theme(legend.position = "bottom",
        strip.background = element_blank(),
        strip.text = element_text(face = "italic",
                                  size = 10)) +
  labs(colour = "")
  
```

**Figure 2.1:** Comparison of three different methods on finding AMPs in different organisms using precision-recall curves. **BLAST1** method is using the proteome of the organism as a database and a FASTA file that contains all AMPs in the SwissProt database, *excluding* the subject organism, as a query. **BLAST2** method is using all AMPs in the SwissProt database as a database, *excluding* the organism proteome, which is used as a query. **Classification** method is where a classification model is trained which contains Swissprot AMPs and non-AMPs of all organisms *excluding* the target organism, and then tested on the target organism proteome.


